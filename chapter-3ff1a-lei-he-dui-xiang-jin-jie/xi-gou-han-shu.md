析构函数（Destructor）

* 复习：构造函数

  * 成员函数的一种
  * 名字**与类名相同**
  * 可以有**参数**，不能有**返回值**
  * 可以有多个构造函数函数
  * 用来**初始化**对象

* 析构函数

  * 名字**与类名相同**
  * 在前面加“**～**”
  * 没有参数和返回值
  * 一个类**最多**只能有**一个**析构函数
  * 在对象消亡时**自动被调用**
    * 在对象消亡前做善后工作
      * 释放分配空间等 （在此之前，如果采用new动态分配内存，那么在各个地方编写delete语句时，需要确保程序的每一条路径上都能释放内存）
      * 有了析构函数后，只需要在析构函数里去使用delete语句，就能够确保对象运行中，使用new分配的空间在对象消亡时都被释放掉了。
  * 定义类时没写析构函数，则编译器**生成缺省析构函数**
    * 不涉及释放用户申请的内存释放等清理工作
  * 定义了析构函数，则编译器不生成缺省的析构函数

    ```
    class String{
        private：
            char * p;
        public:
            String(){
                p=new char[10];        //构造函数里，new出了一个char型的数组，使用一个char*去指向数组的首地址
            }
        ~String();            //定义析构函数
    };
    String::~String(){
        delete [] p;          //在析构函数里对new出的内存空间进行释放，就需要写一个相应的delete语句。
    }                         //这样，在调用析构函数时，自动去delete掉相应的内存空间
                              //注意，对于数组而言，要去delete掉的话，要使用[];否则，只写delete p，只是delete一个对象。
    ```

* 析构函数和数组

  * 对象数组生命期结束时，对象数组的**每个元素**的**析构函数**都会被调用

    ```
    class Ctest{
        public:
            ~Ctest(){
                cout<<"destructor called"<<endl;    //自己定义的析构函数
            } 
    };
    int main(){
        Ctest array[2];            //定义了一个Ctest类下面的数组，包含两个对象
        cout<<"End Main"<<endl;
        return 0;        //程序结束之前，就要释放相应的对象，这时程序就回去调用相应的析构函数
    }
    ——————
    输出
    End Main
    destructor called
    destructor called    //因为有两个数组对象，对应有两次析构函数的调用，因此有两条“destructor called”语句，分别对应两个
                      //数组对象消亡，产生析构函数的调用
    ```

* 析构函数和运算符delete

  * 使用delete语句也可以导致析构函数的调用

    ```
    Ctest * pTest;
    pTest = new Ctest;    //pTest指向new出来的一个Ctest,每次调用new的时候都会使得构造函数被调用到
    delete pTest;         //在new出一片内存空间后，要释放时就需要delete掉，只要使用delete运算，就会调用一个相应的析构函数
    ——————————
    pTest = new Ctest[3];   //new出来了一个数组，构造函数被调用3次
    delete [] pTest;        //析构函数被调用3次
    ```

* 构造函数和析构函数调用时机的例题

* 1



